{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { LinkedList, getBsVer } from 'ngx-bootstrap/utils';\nfunction CarouselComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 7);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r6 = restoredCtx.index;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r7.selectSlide(i_r6));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r5 = ctx.$implicit;\n    i0.ɵɵclassProp(\"active\", slide_r5.active === true);\n  }\n}\nfunction CarouselComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ol\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_1_li_2_Template, 1, 2, \"li\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_ng_container_2_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const i_r11 = restoredCtx.index;\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.selectSlide(i_r11));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    const i_r11 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"active\", slide_r10.active === true);\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r9.currentId)(\"data-bs-slide-to\", i_r11);\n  }\n}\nfunction CarouselComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_button_2_Template, 1, 4, \"button\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.indicatorsSlides());\n  }\n}\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 10);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.previousSlide());\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementStart(2, \"span\", 12);\n    i0.ɵɵtext(3, \"Previous\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r2.checkDisabledClass(\"prev\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r2.currentId);\n  }\n}\nfunction CarouselComponent_a_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 13);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_6_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.nextSlide());\n    });\n    i0.ɵɵelement(1, \"span\", 14);\n    i0.ɵɵelementStart(2, \"span\", 12);\n    i0.ɵɵtext(3, \"Next\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r3.checkDisabledClass(\"next\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#carousel\" + ctx_r3.currentId);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\nconst _c1 = [\"*\"];\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n    this.noWrap = false;\n    /* Show carousel-indicators */\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n      of visible elements (itemsPerSlide field) */\n    this.singleSlideOffset = false;\n  }\n}\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\nCarouselConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CarouselConfig,\n  factory: CarouselConfig.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n  return -1;\n}\nfunction chunkByNumber(array, size) {\n  const out = [];\n  const n = Math.ceil(array.length / size);\n  let i = 0;\n  while (i < n) {\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n  return out;\n}\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n  Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n  constructor(config, ngZone, platformId) {\n    this.ngZone = ngZone;\n    this.platformId = platformId;\n    /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n    this.noWrap = false;\n    /*  If `true` — will disable pausing on carousel mouse hover */\n    this.noPause = false;\n    /*  If `true` — carousel-indicators are visible  */\n    this.showIndicators = true;\n    /*  If `true` - autoplay will be stopped on focus */\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks\n       works ONLY if singleSlideOffset = FALSE */\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n       of visible elements (itemsPerSlide field) */\n    this.singleSlideOffset = false;\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\n    this.isAnimated = false;\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n    this.activeSlideChange = new EventEmitter(false);\n    /** Will be emitted when active slides has been changed in multilist mode */\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n    this.startFromIndex = 0;\n    this._interval = 5000;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.isPlaying = false;\n    this.destroyed = false;\n    this.currentId = 0;\n    this.getActive = slide => slide.active;\n    this.makeSlidesConsistent = slides => {\n      slides.forEach((slide, index) => slide.item.order = index);\n    };\n    Object.assign(this, config);\n    this.currentId = _currentId++;\n  }\n  /** Index of currently displayed slide(started for 0) */\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n    if (isNumber(index)) {\n      this.customActiveSlide = index;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n  get activeSlide() {\n    return this._currentActiveSlide || 0;\n  }\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  get interval() {\n    return this._interval;\n  }\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n  get slides() {\n    return this._slides.toArray();\n  }\n  get isFirstSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n    return indexes.includes(0);\n  }\n  get isLastSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n    return indexes.includes(this._slides.length - 1);\n  }\n  get _bsVer() {\n    return getBsVer();\n  }\n  ngAfterViewInit() {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n      if (this.customActiveSlide && !this.multilist) {\n        this._select(this.customActiveSlide);\n      }\n    }, 0);\n  }\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide) {\n    this._slides.add(slide);\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      if (!this.customActiveSlide) {\n        this.activeSlide = 0;\n      }\n      this.play();\n    }\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide) {\n    const remIndex = this._slides.indexOf(slide);\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n  move(direction, force = false) {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n  keydownPress(event) {\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    }\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    }\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * Play on mouse up\n   * @internal\n   */\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\n   * Starts a auto changing of slides\n   */\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\n   * Stops a auto changing of slides\n   */\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index) {\n    return index === 0;\n  }\n  indicatorsSlides() {\n    return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n  selectInitialSlides() {\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  findNextSlideIndex(direction, force) {\n    let nextSlideIndex = 0;\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return;\n    }\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (!this.isLast(this._currentActiveSlide)) {\n          nextSlideIndex = this._currentActiveSlide + 1;\n          break;\n        }\n        nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n        if (this._currentActiveSlide > 0) {\n          nextSlideIndex = this._currentActiveSlide - 1;\n          break;\n        }\n        if (!force && this.noWrap) {\n          nextSlideIndex = this._currentActiveSlide;\n          break;\n        }\n        nextSlideIndex = this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n    return nextSlideIndex;\n  }\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map((slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n    this.hideSlides();\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    }\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  selectRangeByNestedIndex(index) {\n    if (!this._chunkedSlides) {\n      return;\n    }\n    const selectedRange = this._chunkedSlides.map((slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(slidesList => {\n      return slidesList.list.find(slide => slide.index === index) !== undefined;\n    });\n    if (!selectedRange) {\n      return;\n    }\n    this._currentVisibleSlidesIndex = selectedRange.index;\n    this._chunkedSlides[selectedRange.index].forEach(slide => {\n      slide.item.active = true;\n    });\n  }\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n  isIndexInRange(index) {\n    if (this.singleSlideOffset && this._slidesWithIndexes) {\n      const visibleIndexes = this._slidesWithIndexes.map(slide => slide.index);\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n  hideSlides() {\n    this.slides.forEach(slide => slide.active = false);\n  }\n  isVisibleSlideListLast() {\n    if (!this._chunkedSlides) {\n      return false;\n    }\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n  moveSliderByOneItem(direction) {\n    let firstVisibleIndex;\n    let lastVisibleIndex;\n    let indexToHide;\n    let indexToShow;\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n      const slideToHide = this._slides.get(indexToHide);\n      if (slideToHide) {\n        slideToHide.active = false;\n      }\n      const slideToShow = this._slides.get(indexToShow);\n      if (slideToShow) {\n        slideToShow.active = true;\n      }\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = slidesToReorder;\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n      return;\n    }\n    if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n      return;\n    }\n    let index;\n    firstVisibleIndex = this._slidesWithIndexes[0].index;\n    lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n    if (direction === Direction.NEXT) {\n      this._slidesWithIndexes.shift();\n      index = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes.push({\n          index,\n          item\n        });\n      }\n    } else {\n      this._slidesWithIndexes.pop();\n      index = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n      const item = this._slides.get(index);\n      if (item) {\n        this._slidesWithIndexes = [{\n          index,\n          item\n        }, ...this._slidesWithIndexes];\n      }\n    }\n    this.hideSlides();\n    this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    this.makeSlidesConsistent(this._slidesWithIndexes);\n    this.slideRangeChange.emit(this._slidesWithIndexes.map(slide => slide.index));\n  }\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else if (direction === Direction.NEXT) {\n        this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n      } else {\n        if (this.isVisibleSlideListFirst()) {\n          this._currentVisibleSlidesIndex = this._chunkedSlides ? this._chunkedSlides.length - 1 : 0;\n        } else {\n          this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n        }\n      }\n      if (this._chunkedSlides) {\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(slide => slide.item.active = true);\n      }\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset && this._chunkedSlides) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(slide => slide.index);\n    }\n    if (this._slidesWithIndexes) {\n      return this._slidesWithIndexes.map(slide => slide.index);\n    }\n  }\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n    if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (typeof currentSlide !== 'undefined') {\n        currentSlide.active = false;\n      }\n    }\n    const nextSlide = this._slides.get(index);\n    if (typeof nextSlide !== 'undefined') {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\n   * Starts loop of auto changing of slides\n   */\n  restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0 && isPlatformBrowser(this.platformId)) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return window.setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\n   * Stops loop of auto changing of slides\n   */\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n  checkDisabledClass(buttonType) {\n    if (buttonType === 'prev') {\n      return this.activeSlide === 0 && this.noWrap && !this.multilist || this.isFirstSlideVisible && this.noWrap && this.multilist;\n    }\n    return this.isLast(this.activeSlide) && this.noWrap && !this.multilist || this.isLastSlideVisible && this.noWrap && this.multilist;\n  }\n}\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(CarouselConfig), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n};\nCarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\",\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    isAnimated: \"isAnimated\",\n    activeSlide: \"activeSlide\",\n    startFromIndex: \"startFromIndex\",\n    interval: \"interval\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 7,\n  vars: 8,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"id\", \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"click\"], [\"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [1, \"sr-only\", \"visually-hidden\"], [\"href\", \"javascript:void(0);\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      i0.ɵɵtemplate(1, CarouselComponent_ng_container_1_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵelementStart(3, \"div\", 2);\n      i0.ɵɵprojection(4);\n      i0.ɵɵelementEnd();\n      i0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 3, \"a\", 3);\n      i0.ɵɵtemplate(6, CarouselComponent_a_6_Template, 4, 3, \"a\", 4);\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"id\", \"carousel\" + ctx.currentId);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", !ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(6, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  dependencies: [i2.NgForOf, i2.NgIf, i2.NgStyle],\n  encapsulation: 2\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }],\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }]\n  });\n})();\nclass SlideComponent {\n  constructor(carousel) {\n    /** Is current slide active */\n    this.active = false;\n    this.itemWidth = '100%';\n    this.order = 0;\n    this.isAnimated = false;\n    /** Wraps element by appropriate CSS classes */\n    this.addClass = true;\n    this.multilist = false;\n    this.carousel = carousel;\n  }\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit() {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    this.multilist = this.carousel?.itemsPerSlide > 1;\n  }\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n}\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(i0.ɵɵdirectiveInject(CarouselComponent));\n};\nSlideComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 15,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      i0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      i0.ɵɵclassProp(\"multilist-margin\", ctx.multilist)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated)(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵprojection(1);\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  styles: [\".carousel-animation[_nghost-%COMP%]{transition:opacity .6s ease,visibility .6s ease;float:left}.carousel-animation.active[_nghost-%COMP%]{opacity:1;visibility:visible}.carousel-animation[_nghost-%COMP%]:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}.multilist-margin[_nghost-%COMP%]{margin-right:auto}.carousel-item[_nghost-%COMP%]{perspective:1000px}\"]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      host: {\n        '[attr.aria-hidden]': '!active',\n        '[class.multilist-margin]': 'multilist'\n      },\n      styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }]\n  });\n})();\nclass CarouselModule {\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n}\nCarouselModule.ɵfac = function CarouselModule_Factory(t) {\n  return new (t || CarouselModule)();\n};\nCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"names":["i0","Injectable","EventEmitter","PLATFORM_ID","Component","Inject","Input","Output","HostBinding","NgModule","i2","isPlatformBrowser","CommonModule","LinkedList","getBsVer","CarouselConfig","constructor","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","ɵfac","ɵprov","type","args","providedIn","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","isNumber","value","Object","prototype","toString","call","Direction","_currentId","CarouselComponent","config","ngZone","platformId","isAnimated","activeSlideChange","slideRangeChange","startFromIndex","_interval","_slides","_currentVisibleSlidesIndex","isPlaying","destroyed","currentId","getActive","slide","active","makeSlidesConsistent","slides","forEach","index","item","order","assign","activeSlide","multilist","customActiveSlide","_currentActiveSlide","_select","restartTimer","toArray","isFirstSlideVisible","indexes","getVisibleIndexes","Array","includes","isLastSlideVisible","_bsVer","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","isLast","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","nextSlide","previousSlide","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlide","selectSlideRange","pause","isFirst","indicatorsSlides","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","slideToHide","get","slideToShow","slidesToReorder","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","window","setInterval","nInterval","run","clearInterval","checkDisabledClass","buttonType","NgZone","ɵcmp","NgForOf","NgIf","NgStyle","selector","template","decorators","SlideComponent","carousel","itemWidth","addClass","ngOnInit","host","styles","CarouselModule","forRoot","ngModule","providers","ɵmod","ɵinj","imports","declarations","exports"],"sources":["C:/Users/Admin/OneDrive/Рабочий стол/4 semester/WEB/lab4/node_modules/ngx-bootstrap/carousel/fesm2020/ngx-bootstrap-carousel.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { LinkedList, getBsVer } from 'ngx-bootstrap/utils';\n\nclass CarouselConfig {\n    constructor() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n          of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n}\nCarouselConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nCarouselConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselConfig, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselConfig, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nfunction findLastIndex(array, predicate) {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\nfunction chunkByNumber(array, size) {\n    const out = [];\n    const n = Math.ceil((array.length) / size);\n    let i = 0;\n    while (i < n) {\n        const chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n    constructor(config, ngZone, platformId) {\n        this.ngZone = ngZone;\n        this.platformId = platformId;\n        /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n        this.noWrap = false;\n        /*  If `true` — will disable pausing on carousel mouse hover */\n        this.noPause = false;\n        /*  If `true` — carousel-indicators are visible  */\n        this.showIndicators = true;\n        /*  If `true` - autoplay will be stopped on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks\n           works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n           of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /** Turn on/off animation. Animation doesn't work for multilist carousel */\n        this.isAnimated = false;\n        /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n        this.activeSlideChange = new EventEmitter(false);\n        /** Will be emitted when active slides has been changed in multilist mode */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._interval = 5000;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.isPlaying = false;\n        this.destroyed = false;\n        this.currentId = 0;\n        this.getActive = (slide) => slide.active;\n        this.makeSlidesConsistent = (slides) => {\n            slides.forEach((slide, index) => slide.item.order = index);\n        };\n        Object.assign(this, config);\n        this.currentId = _currentId++;\n    }\n    /** Index of currently displayed slide(started for 0) */\n    set activeSlide(index) {\n        if (this.multilist) {\n            return;\n        }\n        if (isNumber(index)) {\n            this.customActiveSlide = index;\n        }\n        if (this._slides.length && index !== this._currentActiveSlide) {\n            this._select(index);\n        }\n    }\n    get activeSlide() {\n        return this._currentActiveSlide || 0;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     */\n    get interval() {\n        return this._interval;\n    }\n    set interval(value) {\n        this._interval = value;\n        this.restartTimer();\n    }\n    get slides() {\n        return this._slides.toArray();\n    }\n    get isFirstSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(0);\n    }\n    get isLastSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(this._slides.length - 1);\n    }\n    get _bsVer() {\n        return getBsVer();\n    }\n    ngAfterViewInit() {\n        setTimeout(() => {\n            if (this.singleSlideOffset) {\n                this.indicatorsByChunk = false;\n            }\n            if (this.multilist) {\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n                this.selectInitialSlides();\n            }\n            if (this.customActiveSlide && !this.multilist) {\n                this._select(this.customActiveSlide);\n            }\n        }, 0);\n    }\n    ngOnDestroy() {\n        this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param slide\n     */\n    addSlide(slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this.isAnimated) {\n            slide.isAnimated = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            if (!this.customActiveSlide) {\n                this.activeSlide = 0;\n            }\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param slide\n     */\n    removeSlide(slide) {\n        const remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            let nextSlideIndex;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout(() => {\n                this._select(nextSlideIndex);\n            }, 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            const currentSlideIndex = this.getCurrentSlideIndex();\n            setTimeout(() => {\n                // after removing, need to actualize index of current active slide\n                this._currentActiveSlide = currentSlideIndex;\n                this.activeSlideChange.emit(this._currentActiveSlide);\n            }, 0);\n        }\n    }\n    nextSlideFromInterval(force = false) {\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    nextSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    previousSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    }\n    getFirstVisibleIndex() {\n        return this.slides.findIndex(this.getActive);\n    }\n    getLastVisibleIndex() {\n        return findLastIndex(this.slides, this.getActive);\n    }\n    move(direction, force = false) {\n        const firstVisibleIndex = this.getFirstVisibleIndex();\n        const lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * @internal\n     */\n    keydownPress(event) {\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    }\n    /**\n     * Play on mouse leave\n     * @internal\n     */\n    onMouseLeave() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * Play on mouse up\n     * @internal\n     */\n    onMouseUp() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * @internal\n     */\n    pauseFocusIn() {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * @internal\n     */\n    pauseFocusOut() {\n        this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param index: {number} index of slide, which must be shown\n     */\n    selectSlide(index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    }\n    /**\n     * Starts a auto changing of slides\n     */\n    play() {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    }\n    /**\n     * Stops a auto changing of slides\n     */\n    pause() {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     */\n    getCurrentSlideIndex() {\n        return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param index\n     */\n    isLast(index) {\n        return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param index\n     */\n    isFirst(index) {\n        return index === 0;\n    }\n    indicatorsSlides() {\n        return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n    }\n    selectInitialSlides() {\n        const startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = [\n                    ...this._slidesWithIndexes,\n                    ...slidesToAppend\n                ]\n                    .slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n     *   return undefined if next slide require wrapping\n     */\n    findNextSlideIndex(direction, force) {\n        let nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (!this.isLast(this._currentActiveSlide)) {\n                    nextSlideIndex = this._currentActiveSlide + 1;\n                    break;\n                }\n                nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (this._currentActiveSlide > 0) {\n                    nextSlideIndex = this._currentActiveSlide - 1;\n                    break;\n                }\n                if (!force && this.noWrap) {\n                    nextSlideIndex = this._currentActiveSlide;\n                    break;\n                }\n                nextSlideIndex = this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    }\n    mapSlidesAndIndexes() {\n        return this.slides\n            .slice()\n            .map((slide, index) => {\n            return {\n                index,\n                item: slide\n            };\n        });\n    }\n    selectSlideRange(index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            const startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            const endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    selectRangeByNestedIndex(index) {\n        if (!this._chunkedSlides) {\n            return;\n        }\n        const selectedRange = this._chunkedSlides\n            .map((slidesList, i) => {\n            return {\n                index: i,\n                list: slidesList\n            };\n        })\n            .find((slidesList) => {\n            return slidesList.list.find(slide => slide.index === index) !== undefined;\n        });\n        if (!selectedRange) {\n            return;\n        }\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((slide) => {\n            slide.item.active = true;\n        });\n    }\n    isIndexOnTheEdges(index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    }\n    isIndexInRange(index) {\n        if (this.singleSlideOffset && this._slidesWithIndexes) {\n            const visibleIndexes = this._slidesWithIndexes.map((slide) => slide.index);\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    }\n    hideSlides() {\n        this.slides.forEach((slide) => slide.active = false);\n    }\n    isVisibleSlideListLast() {\n        if (!this._chunkedSlides) {\n            return false;\n        }\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    isVisibleSlideListFirst() {\n        return this._currentVisibleSlidesIndex === 0;\n    }\n    moveSliderByOneItem(direction) {\n        let firstVisibleIndex;\n        let lastVisibleIndex;\n        let indexToHide;\n        let indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            const slideToHide = this._slides.get(indexToHide);\n            if (slideToHide) {\n                slideToHide.active = false;\n            }\n            const slideToShow = this._slides.get(indexToShow);\n            if (slideToShow) {\n                slideToShow.active = true;\n            }\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((slide) => slide.item.active);\n            this.makeSlidesConsistent(slidesToReorder);\n            if (this.singleSlideOffset) {\n                this._slidesWithIndexes = slidesToReorder;\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n            return;\n        }\n        if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n            return;\n        }\n        let index;\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n        if (direction === Direction.NEXT) {\n            this._slidesWithIndexes.shift();\n            index = this.isLast(lastVisibleIndex)\n                ? 0\n                : lastVisibleIndex + 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes.push({ index, item });\n            }\n        }\n        else {\n            this._slidesWithIndexes.pop();\n            index = this.isFirst(firstVisibleIndex)\n                ? this._slides.length - 1\n                : firstVisibleIndex - 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes = [{ index, item }, ...this._slidesWithIndexes];\n            }\n        }\n        this.hideSlides();\n        this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this.slideRangeChange.emit(this._slidesWithIndexes.map((slide) => slide.index));\n    }\n    moveMultilist(direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else if (direction === Direction.NEXT) {\n                this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                    ? 0\n                    : this._currentVisibleSlidesIndex + 1;\n            }\n            else {\n                if (this.isVisibleSlideListFirst()) {\n                    this._currentVisibleSlidesIndex = this._chunkedSlides\n                        ? this._chunkedSlides.length - 1\n                        : 0;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            if (this._chunkedSlides) {\n                this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((slide) => slide.item.active = true);\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    }\n    getVisibleIndexes() {\n        if (!this.singleSlideOffset && this._chunkedSlides) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((slide) => slide.index);\n        }\n        if (this._slidesWithIndexes) {\n            return this._slidesWithIndexes.map((slide) => slide.index);\n        }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param index\n     */\n    _select(index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n            const currentSlide = this._slides.get(this._currentActiveSlide);\n            if (typeof currentSlide !== 'undefined') {\n                currentSlide.active = false;\n            }\n        }\n        const nextSlide = this._slides.get(index);\n        if (typeof nextSlide !== 'undefined') {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     */\n    restartTimer() {\n        this.resetTimer();\n        const interval = +this.interval;\n        if (!isNaN(interval) && interval > 0 && isPlatformBrowser(this.platformId)) {\n            this.currentInterval = this.ngZone.runOutsideAngular(() => {\n                return window.setInterval(() => {\n                    const nInterval = +this.interval;\n                    this.ngZone.run(() => {\n                        if (this.isPlaying &&\n                            !isNaN(this.interval) &&\n                            nInterval > 0 &&\n                            this.slides.length) {\n                            this.nextSlideFromInterval();\n                        }\n                        else {\n                            this.pause();\n                        }\n                    });\n                }, interval);\n            });\n        }\n    }\n    get multilist() {\n        return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     */\n    resetTimer() {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    }\n    checkDisabledClass(buttonType) {\n        if (buttonType === 'prev') {\n            return (this.activeSlide === 0 && this.noWrap && !this.multilist) || (this.isFirstSlideVisible && this.noWrap && this.multilist);\n        }\n        return (this.isLast(this.activeSlide) && this.noWrap && !this.multilist) || (this.isLastSlideVisible && this.noWrap && this.multilist);\n    }\n}\nCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });\nCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.0.3\", type: CarouselComponent, selector: \"carousel\", inputs: { noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\", indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", isAnimated: \"isAnimated\", activeSlide: \"activeSlide\", startFromIndex: \"startFromIndex\", interval: \"interval\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngImport: i0, template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\", dependencies: [{ kind: \"directive\", type: i2.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i2.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'carousel', template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"'carousel' + currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"previousSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     href=\\\"javascript:void(0);\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#carousel' + currentId\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\" }]\n        }], ctorParameters: function () { return [{ type: CarouselConfig }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; }, propDecorators: { noWrap: [{\n                type: Input\n            }], noPause: [{\n                type: Input\n            }], showIndicators: [{\n                type: Input\n            }], pauseOnFocus: [{\n                type: Input\n            }], indicatorsByChunk: [{\n                type: Input\n            }], itemsPerSlide: [{\n                type: Input\n            }], singleSlideOffset: [{\n                type: Input\n            }], isAnimated: [{\n                type: Input\n            }], activeSlideChange: [{\n                type: Output\n            }], slideRangeChange: [{\n                type: Output\n            }], activeSlide: [{\n                type: Input\n            }], startFromIndex: [{\n                type: Input\n            }], interval: [{\n                type: Input\n            }] } });\n\nclass SlideComponent {\n    constructor(carousel) {\n        /** Is current slide active */\n        this.active = false;\n        this.itemWidth = '100%';\n        this.order = 0;\n        this.isAnimated = false;\n        /** Wraps element by appropriate CSS classes */\n        this.addClass = true;\n        this.multilist = false;\n        this.carousel = carousel;\n    }\n    /** Fires changes in container collection after adding a new slide instance */\n    ngOnInit() {\n        this.carousel.addSlide(this);\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n        this.multilist = this.carousel?.itemsPerSlide > 1;\n    }\n    /** Fires changes in container collection after removing of this slide instance */\n    ngOnDestroy() {\n        this.carousel.removeSlide(this);\n    }\n}\nSlideComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: SlideComponent, deps: [{ token: CarouselComponent }], target: i0.ɵɵFactoryTarget.Component });\nSlideComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.0.3\", type: SlideComponent, selector: \"slide\", inputs: { active: \"active\" }, host: { properties: { \"attr.aria-hidden\": \"!active\", \"class.multilist-margin\": \"multilist\", \"class.active\": \"this.active\", \"style.width\": \"this.itemWidth\", \"style.order\": \"this.order\", \"class.carousel-animation\": \"this.isAnimated\", \"class.item\": \"this.addClass\", \"class.carousel-item\": \"this.addClass\" } }, ngImport: i0, template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: SlideComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'slide', template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, host: {\n                        '[attr.aria-hidden]': '!active',\n                        '[class.multilist-margin]': 'multilist'\n                    }, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: CarouselComponent }]; }, propDecorators: { active: [{\n                type: HostBinding,\n                args: ['class.active']\n            }, {\n                type: Input\n            }], itemWidth: [{\n                type: HostBinding,\n                args: ['style.width']\n            }], order: [{\n                type: HostBinding,\n                args: ['style.order']\n            }], isAnimated: [{\n                type: HostBinding,\n                args: ['class.carousel-animation']\n            }], addClass: [{\n                type: HostBinding,\n                args: ['class.item']\n            }, {\n                type: HostBinding,\n                args: ['class.carousel-item']\n            }] } });\n\nclass CarouselModule {\n    static forRoot() {\n        return { ngModule: CarouselModule, providers: [] };\n    }\n}\nCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, declarations: [SlideComponent, CarouselComponent], imports: [CommonModule], exports: [SlideComponent, CarouselComponent] });\nCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: CarouselModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule],\n                    declarations: [SlideComponent, CarouselComponent],\n                    exports: [SlideComponent, CarouselComponent]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}